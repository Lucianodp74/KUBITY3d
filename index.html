<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>3D Viewer Pro</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #1a1a1a; color: white; overflow: hidden; height: 100vh; }
        .container { display: flex; height: 100vh; }
        .sidebar { width: 300px; background: #2d2d2d; border-right: 1px solid #444; display: flex; flex-direction: column; overflow-y: auto; }
        .header { padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .logo { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        .section { padding: 15px; border-bottom: 1px solid #444; }
        .section h3 { font-size: 12px; color: #4fc3f7; margin-bottom: 10px; text-transform: uppercase; }
        .upload-btn { width: 100%; padding: 10px; background: #4fc3f7; border: none; border-radius: 6px; color: white; cursor: pointer; margin-bottom: 10px; }
        .sample-btn { padding: 8px 12px; background: #444; border: 1px solid #666; border-radius: 4px; color: #ccc; cursor: pointer; margin: 2px; font-size: 11px; }
        .sample-btn:hover { background: #555; }
        .viewer { flex: 1; position: relative; background: #222; }
        #canvas { width: 100%; height: 100%; }
        .toolbar { position: absolute; top: 20px; right: 20px; background: rgba(45,45,45,0.9); border-radius: 8px; padding: 8px; display: flex; gap: 5px; }
        .tool-btn { width: 36px; height: 36px; background: transparent; border: none; color: #ccc; cursor: pointer; border-radius: 4px; }
        .tool-btn:hover { background: #555; color: white; }
        .info { background: #333; padding: 10px; margin: 5px 0; border-radius: 4px; font-size: 11px; }
        .notification { position: fixed; top: 20px; right: 20px; background: #333; color: white; padding: 10px 15px; border-radius: 6px; transform: translateX(300px); transition: transform 0.3s; z-index: 1000; }
        .notification.show { transform: translateX(0); }
        .notification.success { border-left: 3px solid #4caf50; }
        .notification.error { border-left: 3px solid #f44336; }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="header">
                <div class="logo">3D Viewer Pro</div>
                <div style="font-size: 12px; opacity: 0.8;">Carica file OBJ e DAE</div>
            </div>
            
            <div class="section">
                <h3>File Manager</h3>
                <input type="file" id="fileInput" accept=".obj,.dae" style="display: none;">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    Carica File 3D
                </button>
                <div>
                    <button class="sample-btn" onclick="loadSample('cube')">Cubo</button>
                    <button class="sample-btn" onclick="loadSample('sphere')">Sfera</button>
                    <button class="sample-btn" onclick="loadSample('house')">Casa</button>
                </div>
            </div>
            
            <div class="section">
                <h3>Informazioni</h3>
                <div class="info">
                    <div>File: <span id="fileName">Nessuno</span></div>
                    <div>FPS: <span id="fps">60</span></div>
                    <div>Vertici: <span id="vertices">0</span></div>
                </div>
            </div>
            
            <div class="section">
                <h3>Controlli</h3>
                <div style="font-size: 10px; color: #aaa; line-height: 1.4;">
                    Mouse: Ruota modello<br>
                    Scroll: Zoom<br>
                    Drag: Ruota camera
                </div>
            </div>
        </div>
        
        <div class="viewer">
            <div class="toolbar">
                <button class="tool-btn" onclick="resetView()" title="Reset">üè†</button>
                <button class="tool-btn" onclick="takeScreenshot()" title="Screenshot">üì∑</button>
                <button class="tool-btn" onclick="toggleWireframe()" title="Wireframe">üìê</button>
            </div>
            <div id="canvas"></div>
        </div>
    </div>

<script>
let scene, camera, renderer, currentModel;
let isMouseDown = false, mouseX = 0, mouseY = 0;
let rotX = 0, rotY = 0, targetRotX = 0, targetRotY = 0;
let wireframe = false;

function init() {
    const canvas = document.getElementById('canvas');
    
    if (typeof THREE === 'undefined') {
        canvas.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:white;">Three.js non caricato</div>';
        return;
    }

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    camera.position.set(5, 5, 5);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    renderer.shadowMap.enabled = true;
    canvas.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(10, 10, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 20),
        new THREE.MeshLambertMaterial({ color: 0x333333 })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    setupControls();
    loadSample('cube');
    animate();
    
    window.addEventListener('resize', handleResize);
    showNotification('3D Viewer inizializzato', 'success');
}

function setupControls() {
    const canvas = renderer.domElement;

    canvas.addEventListener('mousedown', (e) => {
        isMouseDown = true;
        mouseX = e.clientX;
        mouseY = e.clientY;
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isMouseDown) return;
        const deltaX = e.clientX - mouseX;
        const deltaY = e.clientY - mouseY;
        targetRotY += deltaX * 0.01;
        targetRotX += deltaY * 0.01;
        mouseX = e.clientX;
        mouseY = e.clientY;
    });

    canvas.addEventListener('mouseup', () => { isMouseDown = false; });

    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoom = e.deltaY * 0.001;
        camera.position.multiplyScalar(1 + zoom);
        const distance = camera.position.length();
        if (distance < 2) camera.position.normalize().multiplyScalar(2);
        if (distance > 50) camera.position.normalize().multiplyScalar(50);
    });
}

function animate() {
    requestAnimationFrame(animate);

    rotX += (targetRotX - rotX) * 0.1;
    rotY += (targetRotY - rotY) * 0.1;

    if (currentModel) {
        currentModel.rotation.x = rotX;
        currentModel.rotation.y = rotY;
    }

    renderer.render(scene, camera);
}

function loadSample(type) {
    if (currentModel) scene.remove(currentModel);

    let geometry, material;

    switch (type) {
        case 'cube':
            geometry = new THREE.BoxGeometry(2, 2, 2);
            material = new THREE.MeshLambertMaterial({ color: 0xff6b6b, wireframe: wireframe }); // Rosso
            currentModel = new THREE.Mesh(geometry, material);
            currentModel.position.y = 1;
            document.getElementById('fileName').textContent = 'Cubo.obj';
            break;
        case 'sphere':
            geometry = new THREE.SphereGeometry(1.5, 32, 32);
            material = new THREE.MeshLambertMaterial({ color: 0x4ecdc4, wireframe: wireframe }); // Turchese
            currentModel = new THREE.Mesh(geometry, material);
            currentModel.position.y = 1.5;
            document.getElementById('fileName').textContent = 'Sfera.obj';
            break;
        case 'house':
            currentModel = new THREE.Group();
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(3, 2, 3), 
                new THREE.MeshLambertMaterial({ color: 0xffa500, wireframe: wireframe }) // Arancione
            );
            base.position.y = 1;
            currentModel.add(base);
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(2.2, 1.5, 4), 
                new THREE.MeshLambertMaterial({ color: 0x8b4513, wireframe: wireframe }) // Marrone
            );
            roof.position.y = 2.75;
            currentModel.add(roof);
            document.getElementById('fileName').textContent = 'Casa.obj';
            break;
    }

    currentModel.castShadow = true;
    scene.add(currentModel);
    document.getElementById('vertices').textContent = geometry ? geometry.attributes.position.count : 'N/A';
    resetView();
    showNotification('Modello ' + type + ' caricato', 'success');
}

function resetView() {
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 1, 0);
    targetRotX = 0;
    targetRotY = 0;
}

function takeScreenshot() {
    const link = document.createElement('a');
    link.download = '3d-screenshot-' + Date.now() + '.png';
    link.href = renderer.domElement.toDataURL();
    link.click();
    showNotification('Screenshot salvato', 'success');
}

function toggleWireframe() {
    wireframe = !wireframe;
    if (currentModel) {
        if (currentModel.traverse) {
            currentModel.traverse(child => {
                if (child.isMesh) child.material.wireframe = wireframe;
            });
        } else {
            currentModel.material.wireframe = wireframe;
        }
    }
    showNotification('Wireframe ' + (wireframe ? 'attivo' : 'disattivo'), 'success');
}

function handleResize() {
    const canvas = document.getElementById('canvas');
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
}

function showNotification(message, type) {
    const notification = document.createElement('div');
    notification.className = 'notification ' + type;
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => notification.classList.add('show'), 100);
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
    }, 2500);
}

// File loading
document.getElementById('fileInput').addEventListener('change', function(e) {
    if (e.target.files.length > 0) {
        const file = e.target.files[0];
        loadFile(file);
    }
});

function loadFile(file) {
    const fileName = file.name.toLowerCase();
    
    if (fileName.endsWith('.obj')) {
        loadOBJ(file);
    } else if (fileName.endsWith('.dae')) {
        loadDAE(file);
    } else {
        showNotification('Formato non supportato', 'error');
    }
}

function loadOBJ(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const geometry = parseOBJ(e.target.result);
            setModel(geometry, file.name);
            showNotification('File OBJ caricato', 'success');
        } catch (error) {
            showNotification('Errore caricamento OBJ', 'error');
        }
    };
    reader.readAsText(file);
}

function loadDAE(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const geometry = parseDAE(e.target.result);
            setModel(geometry, file.name);
            showNotification('File DAE caricato', 'success');
        } catch (error) {
            showNotification('Errore caricamento DAE', 'error');
        }
    };
    reader.readAsText(file);
}

function parseOBJ(data) {
    const vertices = [];
    const faces = [];
    const lines = data.split('\n');
    
    for (const line of lines) {
        const parts = line.trim().split(/\s+/);
        
        if (parts[0] === 'v') {
            vertices.push(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
        } else if (parts[0] === 'f') {
            const indices = parts.slice(1).map(p => parseInt(p.split('/')[0]) - 1);
            if (indices.length >= 3) {
                for (let i = 1; i < indices.length - 1; i++) {
                    faces.push(indices[0], indices[i], indices[i + 1]);
                }
            }
        }
    }
    
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geometry.setIndex(faces);
    geometry.computeVertexNormals();
    return geometry;
}

function parseDAE(data) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(data, 'text/xml');
    const vertices = [];
    const faces = [];
    
    const sources = xmlDoc.getElementsByTagName('source');
    for (const source of sources) {
        const floatArray = source.getElementsByTagName('float_array')[0];
        if (floatArray) {
            const values = floatArray.textContent.trim().split(/\s+/).map(parseFloat);
            for (let i = 0; i < values.length; i += 3) {
                vertices.push(values[i], values[i + 1], values[i + 2]);
            }
            break;
        }
    }
    
    const triangles = xmlDoc.getElementsByTagName('triangles')[0];
    if (triangles) {
        const p = triangles.getElementsByTagName('p')[0];
        if (p) {
            const indices = p.textContent.trim().split(/\s+/).map(parseInt);
            for (let i = 0; i < indices.length; i += 3) {
                faces.push(indices[i], indices[i + 1], indices[i + 2]);
            }
        }
    }
    
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geometry.setIndex(faces);
    geometry.computeVertexNormals();
    return geometry;
}

function setModel(geometry, fileName) {
    if (currentModel) scene.remove(currentModel);
    
    const material = new THREE.MeshLambertMaterial({ color: 0x4fc3f7, wireframe: wireframe, side: THREE.DoubleSide });
    currentModel = new THREE.Mesh(geometry, material);
    currentModel.castShadow = true;
    
    const box = new THREE.Box3().setFromObject(currentModel);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    
    currentModel.position.copy(center).negate();
    currentModel.position.y = size.y / 2;
    
    const maxDim = Math.max(size.x, size.y, size.z);
    if (maxDim > 10) {
        const scale = 10 / maxDim;
        currentModel.scale.setScalar(scale);
    }
    
    scene.add(currentModel);
    document.getElementById('fileName').textContent = fileName;
    document.getElementById('vertices').textContent = geometry.attributes.position.count;
    resetView();
}

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
